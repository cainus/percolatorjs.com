
<!DOCTYPE html>
<html lang="en" ng-app="percdocs">
  <head>
    <meta charset="utf-8">
    <title>percolator.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
    </style>
    <link href="css/bootstrap-responsive.css" rel="stylesheet">
    <link href="css/sh_acid.min.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
    <script type="text/javascript" src="/js/sh_main.min.js"></script>
    <script type="text/javascript" src="/js/sh_javascript.min.js"></script>
  </head>

  <body  onload="sh_highlightDocument();">

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/img/headr-nav.png" /></a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="about.html">About</a></li>
              <li><a href="https://github.com/cainus/percolator">Source Code</a></li>
              <li class="active"><a href="documentation.html">Documentation</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container">
      <div >
        <h3>
        Documentation
        </h3>
     <div>
      <h4>Installation</h4>
      <code>npm install Percolator</code>
      <h4>Running Tests</h4>
      <code>make test</code>
      <h4>Hello World Quick Start:</h4>

<ul>
<li> Create a <code>server.js</code> in your project directory, and copy this code below into it:</li>
<pre class="sh_javascript">
var Percolator = require('Percolator').Percolator;

var server = new Percolator();
server.route('/', {  GET : function($){
                              $.json({message : 'Hello World!'}).send();
                            }});
server.listen(function(err){
  console.log('server is listening on port ', server.port);
});
</pre>

</ul>
<ul>
<li>
<p>Run the server:
<code>node server.js</code>
</p>
</li>
<li><p>See your "Hello World" output at http://localhost:3000/ and be completely floored by the greatest 
API of all time.  Or not.</p>
The output json look like this:
<pre class="sh_javascript">
{
  message: "Hello World!",
  _links: {
    self: {
      href: "http://localhost:3000/"
    }
  }
}
</pre >

You'll notice that Percolator automatically adds a link to the document itself.  This is because 
it tries to help you create a surfable "Hypermedia" API where every endpoint is accessible from a link
in another endpoint, and where everything that can be done with the API is described in the API
itself.
</li>
</ul>

<div class="alert alert-success">
  <h4>Why should I care about Hypermedia??!?</h4>
  <p>
  Because Hypermedia APIs are pretty awesome for the people using your API.
  </p>
  <p>
  Developers can find their way to all your endpoints just by following the links in the json payload
  instead of having to read a bunch of docs.  Using a browser plugin like JSONView for 
  <a href="http://jsonview.com/">Firefox</a> or 
  <a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc">chrome</a> 
  makes it so developers can just surf around your API in their browser as if your 
  responses are regular web pages.
  </p>
  <p>
  These types of APIs are machine-readable as well, so they're spider-able, and even allow automatic 
  form generation, or automated fuzz-testing.
  </p>

  <p>
  In other frameworks adding links everywhere can be time-consuming.  Percolator makes this either 
  automatic or very easy though.

  </p>
  <p>
  NOTE:  If you're worried about the size of your responses, keep in mind that 
  with proper caching and compression (gzip), there should be little to no cost to your 
  clients' performance or bandwidth.
  </p>
</div>

<h4>The Percolator Server Object</h4>
Any Percolator objects you create are just http servers (based on 
<a href="https://github.com/cainus/oneone">oneone</a>) with a bunch of helpers
for making JSON APIs more easily.

<h5>The constructor</h5>
The constructor returns a percolator server.  It can take an optional single object as 
a parameter like so:

<pre class="sh_javascript">
var server = new Percolator({"some" : "object"});
</pre>
<p>
This is called the <strong>app</strong> object.
</p>
<p>

Anything you put in the app object will be available to all your HTTP handlers, so it's 
great for shared configuration, database objects, etc.
</p>

<p>Additionally, the constructor recognizes a few special properties of the app object:</p>

<p><strong>protocol</strong> - 'http' or 'https'<br>
<strong>resourcePath</strong> - the url path that all the resource will be routed from (eg. Setting it to '/' will serve the 
  resources from <a href="http://yourdomain.com/">http://yourdomain.com/</a> while setting it to '/api' will serve the resources from 
  <a href="http://yourdomain.com/api">http://yourdomain.com/api</a> .<br>
<strong>staticDir</strong> - The directory on the filesystem from which you will serve static content (use an absolute path!).<br><strong>port</strong> - the http port.  A low port like 80 will not work unless you run the app with root privileges.  </p>

<p>You're obviously going to want to limit the number of app object variables that you add beyond the necessary ones, but
certain types of objects might make sense in that shared space.</p>
    </div>

<h5>route(routeString, resourceObject)</h5>
<p>
The route() method of the server takes two parameters, the route string and the resource object.
</p>

<p>
It then sets a route using the route string that the given resource object will handle when
an incoming request matches that route.
</p>

<p>
Route strings can be regular expressions, or 
<a href="http://expressjs.com/api.html">express</a>/sinatra-style route strings.
</p>

<p>
The resource object is any object that has methods on it that match HTTP methods like POST, PUT, GET, 
DELETE, etc.  The method takes only one parameter: the context object ($).
</p>

<p>
The Hello World example above has a resource object that implements only GET:
</p>
<pre class="sh_javascript">
{
  GET : function($){
    $.json({message : 'Hello World!'}).send();
  }
}
</pre>
Of course, other HTTP methods (PUT, POST, DELETE, etc) can be added to this object as well to
make this API do more.  Here it is, passed to route() with a routeString of '/', the root path:

<pre class="sh_javascript">
server.route('/', {  GET : function($){
                              $.json({message : 'Hello World!'}).send();
                            }});
</pre>

Note that because resource objects are just objects, you can load them from a file as modules, or create
components that you re-use for different modules.


<h5>listen([cb])</h5>
Call listen() on the server to start it listening.  The default port (unless overridden by 
the app object) is 3000.

listen() takes an optional callback as well, that is called when the server is listening, or 
when there's been an error.  The error will be the first parameter to this callback, if it exists.

<pre class="sh_javascript">
server.listen(function(err){
  console.log('server is listening on port ', server.port);
});
</pre>

<h5>onRequest(cb)</h5>
<p>
The onRequest() method takes a callback as its only parameter.  The callback is called when
a request occurs.
</p>

<p>
The callback takes handler, context and cb parameters.  
</p>

<p>
The <strong>handler</strong> is the resource object that is routed to the request url in 
the router.  It will contain the functions meant to handle the different HTTP methods.
</p>
<p>
The <strong>context</strong> ($) is the context object.  If you want to augment the 
context object for some reason, for all requests, this is a great place to do it.
</p>
<p>
The <strong>cb</strong> parameter is a callback that will be called to 'return' the 
context object.  The context object should be its only parameter.
</p>

<p>
Here's an example:
</p>

<pre class="sh_javascript">
server.onRequest(function(handler, $, cb){
  // print the request method and url for every request.
  console.log(' <-- ', $.req.method, ' ', $.req.url);
  cb(context);
});
</pre>

<h4>The Context Object ($)</h4>
The "Hello World" example should be pretty straightforward, except it has a strange dollar sign ($) in it.  
This is the context object.  The context object is basically just a holder for all the things your request 
handler will care about.  You can name it whatever you want really, but '$' is a nice short name that you're
unlikely to have a clash with in a server-side environment.  It has a number of interesting properties:

<h5>$.req</h5>
This is the unaltered <a href="http://nodejs.org/api/http.html#http_class_http_serverrequest">request object</a> from the node.js standard library.

<h5>$.res</h5>
This is the unaltered <a href="http://nodejs.org/api/http.html#http_class_http_serverrequest">response object</a> from the node.js standard library.

<h5>$.app</h5>
This is the app object that you passed in the constructor to Percolator.

<h5>$.status</h5>
<p>
The status module is automatically attached to your resource handler at request time. It is just a bunch of helper functions for dealing with response statuses.
</p>

<p>
This is an important module because building great APIs requires excellent and consistent error and status reporting.
</p>

<p>
To understand what the codes mean, please refer to <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a>.
</p>

<h6>Usage</h6>
These methods generally set the HTTP status and end the response, so in general you should not expect to write more to the response after these. If a response body makes sense, it will generally be written automatically. For clarity, it's recommended that when you call one of these functions, you call it with <code>return</code> in front of it. Here's an example:

<pre class="sh_javascript">
server.route('/', {  GET : function($){
                              return $.status.redirect('/someOtherUrl');
                            }});
</pre>
<p>
Here are the functions that it makes available in your method handler:
</p>

<h6>Redirect scenarios</h6>
<dl>
  <dt>
$.status.created(redirectUrl);
  </dt>
  <dd>
This method is used for HTTP STATUS 201 scenarios when the server has just created a resource successfully so that the server can tell the client where to find it. It sets the status to 201 and sets the 'Location' header to the redirectUrl.
  </dd>
</dl>

<dl>
  <dt>
    $.status.movedPermanently(redirectUrl);
  </dt>
  <dd>
    This method is used for HTTP STATUS 301 scenarios where a resource has been permanently moved somewhere else so the server can tell the client where to find it. It sets the status to 301 and sets the 'Location' header to the redirectUrl.
  </dd>
</dl>

<dl>
  <dt>
    $.status.redirect(redirectUrl);
  </dt>
  <dd>
    This is just an alias of movedPermanently()
  </dd>
</dl>

<h6>Success responses</h6>
<p>
"200 OK" statuses are the default, so you don't need to specify those explicitly.
</p>
<p>
201 Created statuses are described in the redirect section above.
</p>

<dl>
  <dt>
    $.status.accepted();
  </dt>
  <dd>
    Used to indicate that a response has been accepted, but not yet processed, this response will emit a "202 Accepted" status.
  </dd>
</dl>

<h6>Error Scenarios</h6>
All of the error scenarios are handled similarly and attempt to show a response body that indicates the error that occurred as well. The status code will be set on the response as well as in that response body.

All of these methods additionally take a single parameter where additional detail information can be added. For example:

<pre class="sh_javascript">
server.route('/', {  GET : function($){
                              return $.status.internalServerError('The server is on fire.');
                            }});
</pre>

Output:<br />
<code>
{"type":500,"message":"Internal Server Error","detail":"The server is on fire"}
</code>
<h6>Error response methods:</h6>

<dl>
  <dt>
    $.status.badRequest([detail])
  </dt>
  <dd>
    <code>
    {"type":400,"message":"Bad Request"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
    $.status.unauthenticated([detail])
  </dt>
  <dd>
    <code>
      {"type":401,"message":"Unauthenticated"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.forbidden([detail])
  </dt>
  <dd>
    <code>
      {"type":403,"message":"Forbidden"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.notFound([detail])
  </dt>
  <dd>
    <code>
        {"type":404,"message":"Not Found"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.methodNotAllowed([detail])
  </dt>
  <dd>
    <code>
      {"type":405,"message":"Method Not Allowed"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.notAcceptable([detail])
  </dt>
  <dd>
    <code>
      {"type":406,"message":"Not Acceptable"}
    </code>
  </dd>
</dl>


<dl>
  <dt>
      $.status.conflict([detail])
  </dt>
  <dd>
    <code>
        {"type":409,"message":"Conflict"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.gone([detail])
  </dt>
  <dd>
    <code>
        {"type":410,"message":"Gone"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.lengthRequired([detail])
  </dt>
  <dd>
    <code>
        {"type":411,"message":"Length Required"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.preconditionFailed([detail])
  </dt>
  <dd>
    <code>
        {"type":412,"message":"Precondition Failed"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.requestEntityTooLarge([detail])
  </dt>
  <dd>
    <code>
        {"type":413,"message":"'Request Entity Too Large"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.requestEntityTooLarge([detail])
  </dt>
  <dd>
    <code>
        {"type":413,"message":"'Request Entity Too Large"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
$.status.requestUriTooLong([detail])
  </dt>
  <dd>
    <code>
{"type":414,"message":"Request URI Too Long"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
$.status.unsupportedMediaType([detail])
  </dt>
  <dd>
    <code>
{"type":415,"message":"Unsupported Media Type"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
$.status.unprocessableEntity([detail])
  </dt>
  <dd>
    <code>
{"type":422,"message":"'Unprocessable Entity"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
$.status.tooManyRequests([detail])
  </dt>
  <dd>
    <code>
{"type":429,"message":"Too Many Requests"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
$.status.internalServerError([detail])
  </dt>
  <dd>
    <code>
{"type":500,"message":"Internal Server Error"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
$.status.notImplemented([detail])
  </dt>
  <dd>
    <code>
{"type":501,"message":"Not Implemented"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
$.status.badGateway([detail])
  </dt>
  <dd>
    <code>
{"type":502,"message":"Bad Gateway"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.serviceUnavailable([detail])
  </dt>
  <dd>
    <code>
        {"type":503,"message":"Service Unavailable"}
    </code>
  </dd>
</dl>

<dl>
  <dt>
      $.status.gatewayTimeout([detail])
  </dt>
  <dd>
    <code>
        {"type":504,"message":"Gateway Timeout"}
    </code>
  </dd>
</dl>


<h5>$.uri</h5>
<p>
Each method you define has access to a 'uri' module that understands the context of each particular request that it's used in. The module makes a number of convenient methods available for dealing with uri's and generally making the parsing of uri's simpler and the creation of new uri's simple. Here are example usages:
</p>

<h6> General Usage: </h6>

<pre class="sh_javascript">
server.route('/', {  GET : function($){
                              $.json({self : $.uri.self()}).send();
                                // --> {"self" : "http://example.com/currentUrl"}
                            }});
</pre>
<h6>Api specifics:</h6>
<dl>
  <dt>
    $.uri.absolute(path)
  </dt>
  <dd>
    Takes a relative path and returns an absolute path using the hostname header.
    <pre class="sh_javascript">
$.uri.absolute("/somepath");
// returns "http://hostname.com/somepath" </pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.child(suffix);
  </dt>
  <dd>
Returns the current url with the given suffix added to the path as the last 
"folder".  For example, if the current URI is http://localhost/artist/1234/, then...
    <pre class="sh_javascript">
$.uri.child('song');
// ... would return http://localhost/artist/1234/song
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.get(path [, variableHash]);
  </dt>
  <dd>
Gets a url by path. An optional hash may be passed of variables to fill in necessary path variables.
    <pre class="sh_javascript">
$.uri.get('/artist/:artist', {artist : 1234});
// could return something like:  'http://hostname.com/artist/1234' if such a route exists.
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.param(name)
  </dt>
  <dd>
Retrieves the specified param value by the input param name from the object returned by $.uri.params() (see above).
For example, if the URI is http://localhost/artist/1234/song/5678, then...
    <pre class="sh_javascript">
$.uri.param("song");
// ... will return 5678
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.params()
  </dt>
  <dd>
returns an object containing the name/value pairs of variables extracted from the uri's "path" (NOT including querystring). An optional uri may be passed in, but the default is to use the current request's uri.

For example, if the URI is http://localhost/artist/1234/song/5678, then...
    <pre class="sh_javascript">
$.uri.params()
// ... will return:
{ artist : 1234, song : 5678 }
</pre>
  </dd>
</dl>
<dl>
  <dt>
$.uri.parent();
  </dt>
  <dd>
Get the parent URI of the current URI. An optional URI may be passed in to get its' parent's URI instead.
    <pre class="sh_javascript">
$.uri.parent("http://asdf.com/asdf");
// returns "http://asdf.com/"
</pre>
  </dd>
</dl>


<dl>
  <dt>
$.uri.parse([url]);
  </dt>
  <dd>
Returns the result of <a href="http://nodejs.org/docs/v0.9.0/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost">node's url.parse</a> for the current URI. An optional URI can be passed to use that one instead.
    <pre class="sh_javascript">
$.uri.parse();
//returns:
{ href : 'http://somehostname.com:8080/artist/1234/song?genre=hiphop', 
  protocol : 'http', 
  host : 'somehostname.com:8080', 
  hostname : 'somehostname.com', 
  port : 8080,
  pathname : '/artist1234',
  search : '?genre=hiphop'}
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.pathEnd([url]);
  </dt>
  <dd>
Returns the last "folder" in the path of the given url.  If no url is given, then the current url
is used.
    <pre class="sh_javascript">
$.uri.pathEnd('http://asdf.com/a/b/c');
// ... would return 'c':
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.pathJoin(...);
  </dt>
  <dd>
Takes a list of strings and arrays of strings and returns a forward-slash-delimited path of all the pieces in the order that they appear (without a trailing slash).
    <pre class="sh_javascript">
$.uri.pathJoin("asdf", ["qwer", "tyui"], "1234");
returns '/asdf/qwer/tyui/1234'
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.query([url]);
  </dt>
  <dd>
Get the querystring data from the current url as an object with the name/value pairs in the querystring. An alternative url can optionally be passed in.
    <pre class="sh_javascript">
$.uri.query('http://asdf.com/path/?this=is&a=test');
// returns: 
{ this:is, a:test }
</pre>
  </dd>
</dl>


<dl>
  <dt>
$.uri.queryString(queryHash);
  </dt>
  <dd>
Take an input object and create a querystring of the name/value pairs in the queryHash.
    <pre class="sh_javascript">
$.uri.queryString({ this:is, a:test }});
// returns: '?this=is&a=test'
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.self()
  </dt>
  <dd>
returns the current uri (as an absolute uri).
    <pre class="sh_javascript">
$.uri.self();
// returns 'http://hostname.com/thecurrentpath/'  (if that's the current url)
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.urlDecode(someEncodedStr)
  </dt>
  <dd>
take a url-encoded string and return a decoded version of it.
    <pre class="sh_javascript">
$.uri.urlDecode("this%20is%20a%20test");
// returns "this is a test"
</pre>
  </dd>
</dl>

<dl>
  <dt>
$.uri.urlEncode(somestr);
  </dt>
  <dd>
take a string and return a url-encoded version of it. This method uses node's querystring module's escape().
    <pre class="sh_javascript">
$.uri.urlEncode("this is a test");
// returns "this%20is%20a%20test"
</pre>
  </dd>
</dl>

<h5>$.json</h5>

$.json is a function that takes an object for later output as json.  It returns a "HyperJSON" object which is just 
a fluid (chained) interfaced for creating json with links easily.


<dl>
  <dt>
     toString()
  </dt>
  <dd>
    returns a json string representation of the input object.
    <pre class="sh_javascript">
$.json({some : "test"}).toString();
// returns '{"some":"test"}'
</pre>
  </dd>
</dl>

<dl>
  <dt>
     toObject()
  </dt>
  <dd>
    returns your input object, with any alterations you've made so far
    <pre class="sh_javascript">
$.json({some : "test"}).toObject();
// returns {some:"test"}
</pre>
  </dd>
</dl>

<dl>
  <dt>
     property(name, value)
  </dt>
  <dd>
    adds a property to your input object
    <pre class="sh_javascript">
$.json({some : "test"}).property("also", "this").toObject();
// returns {some:"test",also:"this"}
</pre>
  </dd>
</dl>

<dl>
  <dt>
     link(rel, href, [options])
  </dt>
  <dd>
    adds a link to your input object
    <pre class="sh_javascript">
$.json({some : "test"}).link("somerel", "http://some.example.com").toObject();
// returns {some:"test",_links:{somerel:{href:"http://some.example.com"}}}
</pre>
  </dd>
  <dd>
    The options object can be used to specify the http method with a 'method' property and
    a json schema with a 'schema' property   The schema property should be an object that, when converted to
    json, is a valid <a href="http://json-schema.org/">json schema</a> object.
    <pre class="sh_javascript">
$.json({some : "test"}).link("somerel", "http://some.example.com", {method:"POST", schema:{}}).toObject();
// returns {some:"test",_links:{somerel:{href:"http://some.example.com",method:"POST",schema:{}}}}
</pre>
  </dd>
</dl>

<dl>
  <dt>
     send()
  </dt>
  <dd>
    sends the input object as json in the http response and ends the response.
    <pre class="sh_javascript">
$.json({some : "test"}).send();
</pre>
  </dd>
</dl>

<h5>$.jsonCollection</h5>
This object is meant for creating and manipulating json "collections" which are useful in general when you want
to output a list of things in json.  It has all the same capibilities as $.json, but it also adds some additional
capability for dealing with the individual items in the list.

$.jsonCollection() is function that takes either an array or an object that will be treated as a hash.  It will
 then add that list/hash to an _items property in a wrapper object.

<pre class="sh_javascript">
// object/hash version
$.jsonCollection({someitem : "1234",someotheritem : 4567}).toObject();
// returns:
{
  _items : {
    someitem : "1234",
    someotheritem : "4567"
  }
}
</pre>
  </dd>
</dl>

<pre class="sh_javascript">
// array version
$.jsonCollection([{someitem : "1234"],{someotheritem : 4567}]).toObject();
// returns:
{
  _items : [
    {someitem : "1234"},
    {someotheritem : "4567"}
  ]
}

</pre>
  </dd>
</dl>



<dl>
  <dt>
     each(cb)
  </dt>
  <dd>
    runs a given callback on each item in the list.  The list can be an array or an object that will be 
    treated as a hash. The callback takes an individual item as its only parameter and replaces that item 
    with the return value 
    <pre class="sh_javascript">
$.jsonCollection({some : "test"}).each(function(item){return item + "2";}).toObject();
// returns {_items : {some:"test2"}}
$.jsonCollection([{some:"test"}]).each(function(item){return item + "2";}).toObject();
// returns {_items:[{some:"test2"}]}
</pre>
<!-- TODO verify the output of these.  Add parent/self links as well. -->
  </dd>
</dl>


<dl>
  <dt>
     linkEach(rel, cb)
  </dt>
  <dd>
    You can use this function for adding a link to each item in the collection.  The 
    <strong>rel</strong> argument is
    the rel property of the link.  The rel property is usually a way of describing what this link 
    will lead to.  There are a bunch of 
<a href="http://www.iana.org/assignments/link-relations/link-relations.xml">predefined rel names</a> 
    or you can make your own.
    The <strong>cb</strong> argument is a callback that will be run on each item in the list and to create a link with the given rel 
    from the callback's return value and add it to that item.  The callback takes an individual item as its 
    only parameter and replaces that item with the return value 
<pre class="sh_javascript">
$.jsonCollection({some : "test"}).linkEach('plustwo', function(item){return 'http://server.com/' + item + "2";}).toObject();
// returns: 
{
  _items : {
    some:"test2"
  }
}
</pre>
<pre class="sh_javascript">
$.jsonCollection([{some : "test"}]).linkEach('plustwo', function(item){return 'http://server.com/' + item['some'] + "2";}).toObject();
// returns 
{
  _items : [
    { some:"test2"}
  ]
}
</pre>
<!-- TODO verify the output of these.  Add parent/self links as well. -->
  </dd>
</dl>



<h5>$.onJson([schema], cb)</h5>
<p>
$.onJson() is used for handling a request where the request body is json (normally a PUT or POST).  It 
takes care of accepting the incoming stream, attempting to parse it to json, and automatically 
sending a 400 error if it does not parse.
</p>
<p>
The first, <em>optional</em> parameter, <strong>schema</strong>,  is a 
<a href="http://json-schema.org/">json schema</a> as a javascript object (not as a string).  This 
schema object can be used to validate the incoming json object if desired.  $.onJson will return 
an appropriate error to the user if the incoming json is not acceptable according to the schema.
</p>
<p>
The last (or only) parameter is a callback that is used if the incoming json parses successfully.  
The callback will take an 'error' and an 'object' parameter, where the error parameter will contain 
any error that was not automatically handled (like a network error), and the object parameter will 
contain any object that was deserialized from the incoming json (if possible).
</p>
<pre class="sh_javascript">
// without a json schema...
$.onJson(function(err, obj){
  console.log('error: ', err);
  console.log('object: ', obj);
});
</pre>
<pre class="sh_javascript">
// with a json schema...
var schema = {
    properties : {
      "username" : {
        type : "string",
        required : true
      }
    };
$.onJson(schema, function(err, obj){
  console.log('error: ', err);
  console.log('object: ', obj);
});
</pre>




<h5>$.onBody(cb)</h5>
<p>
$.onBody() is used for handling the streaming of non-json request bodies.
</p>
<p>
The only parameter is a callback that takes an error and a body parameter.  The <strong>error
</strong> parameter will be null unless an error occurred during streaming of the body, in 
which case it will contain the error.  The <strong>body</strong> parameter will contain the
request body as a string for use inside the callback.
</p>

<pre class="sh_javascript">
$.onBody(function(err, body){
  console.log('error: ', err);
  console.log('body: ', body);  // body is just a string here
});
</pre>
<p>
NOTE: If you're expecting json, then you should normally use $.onJson() instead of this method.
</p>

<!--
<h4>Resource Objects</h4>
// TODO
// authenticate
// basicAuthenticate
// fetch
// handler and wildcard

<h4>JsonModule</h4>
// TODO.  should there be a rename first?  CRUDModule?
// list
// upsert
// create
// update
// schema
// updateSchema
// createSchema
// destroy
// fetch
// collectionGET
// memberGET
// handler / wildcard
-->

<h4>Advanced Routing</h4>
<h5>Hello World Refactored:</h5>

<p>Percolator also allows a more advanced style of routing that lets you load 
your route-handling resources from external files instead.</p>

<ul>
<li>With the "Hello World" example, we could instead move the handler into a file at the path 
<code>./resources/index.js</code>.  (First create a <code>resources</code> directory and 
then the <code>index.js</code> file in it, and then copying the handler logic into 
<code>index.js</code> like so:</li>
</ul>
<pre class="sh_javascript">
exports.handler = {
  GET : function(req, res){
    res.end('Hello World!');
  }
}
</pre>
We'll call files like that "resources" from now on.

<ul>
<li>Change your server.js to call <code>routeDirectory()</code> instead of <code>server.route()
</code> like so:</li>
</ul>

<pre class="sh_javascript">
var Percolator = require('Percolator');

var server = new Percolator();
server.routeDirectory(__dirname + '/resources', '/api', function(err){
  if (!!err) {console.log(err);}
  server.listen(function(err){
    console.log('server is listening on port ', server.port);
  });
});
</pre>

<ul>
<li>
<p>Run the server:
<code>node server.js</code>
</p>
</li>
<li><p>See your "Hello World" output at http://localhost:3000/api .  You should see the same output
as the original "Hello World" example.</p></li>
</ul>
<p>
This worked because index.js is the reserved filename for responding to '/'.  If you want to respond
to uris like '/hello', you can simply drop a <code>hello.js</code> in that folder (that exports a 
similar handler) and it will respond to http://localhost:3000/api/hello .  The advantage to this way 
of routing is that all your resources can be in separate files so that your project can be more easily
organized.
</p>
    </div>


    <!--  END DOCS --> 
      </div>

    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script src="js/bootstrap-transition.js"></script>
    <script src="js/bootstrap-alert.js"></script>
    <script src="js/bootstrap-modal.js"></script>
    <script src="js/bootstrap-dropdown.js"></script>
    <script src="js/bootstrap-scrollspy.js"></script>
    <script src="js/bootstrap-tab.js"></script>
    <script src="js/bootstrap-tooltip.js"></script>
    <script src="js/bootstrap-popover.js"></script>
    <script src="js/bootstrap-button.js"></script>
    <script src="js/bootstrap-collapse.js"></script>
    <script src="js/bootstrap-carousel.js"></script>
    <script src="js/bootstrap-typeahead.js"></script>
    <script src="js/bootstrap-affix.js"></script>
   <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-10626105-12']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script> 
    

  </body>
</html>


